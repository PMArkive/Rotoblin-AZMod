/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include <sdktools>
#include <sdkhooks>
#include <multicolors>

public Plugin:myinfo = 
{
	name = "L4D FF Announce Plugin",
	author = "Frustian",
	description = "Adds Friendly Fire Announcements + pig survivor notify",
	version = "1.8",
	url = "https://steamcommunity.com/profiles/76561198026784913/"
}
//cvar handles
ConVar FFenabled;
ConVar AnnounceType
//Various global variables
new DamageCache[MAXPLAYERS+1][MAXPLAYERS+1]; //Used to temporarily store Friendly Fire Damage between teammates
Handle FFTimer[MAXPLAYERS+1]; //Used to be able to disable the FF timer when they do more FF //Stores whether players are in a state of friendly firing teammates
static bool:ClientHasDown[MAXPLAYERS + 1];
static bool:ClientGrabLedge[MAXPLAYERS + 1];
native bool:IsTankPounchClient(client);//From l4d_tankpunchstuckfix

native IsInReady();
public OnPluginStart()
{
	LoadTranslations("Roto2-AZ_mod.phrases");
	CreateConVar("l4d_ff_announce_version", "1.4", "FF announce Version",FCVAR_SPONLY|FCVAR_NOTIFY);
	FFenabled = CreateConVar("l4d_ff_announce_enable", "1", "Enable Announcing Friendly Fire",FCVAR_SPONLY|FCVAR_NOTIFY);
	AnnounceType = CreateConVar("l4d_ff_announce_type", "1", "Changes how ff announce displays FF damage (1:In chat; 2: In Hint Box; 3: In center text)",FCVAR_SPONLY);
	HookEvent("player_hurt_concise", Event_HurtConcise, EventHookMode_Post);
	HookEvent("player_death", Event_PlayerDeath);
	HookEvent("round_start", Event_RoundStart)
	HookEvent("player_ledge_grab", Event_ledge_grab);
	HookEvent("revive_success", Event_revive_success);//救起倒地的or 懸掛的
	HookEvent("player_bot_replace", OnBotSwap);
	HookEvent("bot_player_replace", OnBotSwap);
	HookEvent("player_spawn", OnPlayerSpawn);
	HookEvent("player_incapacitated_start", Event_IncapacitatedStart);

	HookEvent("round_end",				Event_RoundEnd,		EventHookMode_PostNoCopy); //trigger twice in versus mode, one when all survivors wipe out or make it to saferom, one when first round ends (second round_start begins).
	HookEvent("map_transition", 		Event_RoundEnd,		EventHookMode_PostNoCopy); //all survivors make it to saferoom, and server is about to change next level in coop mode (does not trigger round_end) 
	HookEvent("mission_lost", 			Event_RoundEnd,		EventHookMode_PostNoCopy); //all survivors wipe out in coop mode (also triggers round_end)
	HookEvent("finale_vehicle_leaving", Event_RoundEnd,		EventHookMode_PostNoCopy); //final map final rescue vehicle leaving  (does not trigger round_end)
	
}

public void OnMapEnd()
{
	ResetTimer();
}

public void Event_RoundEnd(Event event, const char[] name, bool dontBroadcast) 
{
	ResetTimer();
}

public Action:Event_RoundStart(Handle:event, const String:name[], bool:dontBroadcast)
{
	for(new i = 1; i <= MaxClients; i++) 
	{
		ClientHasDown[i] = false;	
		ClientGrabLedge[i] = false;	
	}
}

public Event_PlayerDeath(Handle:event, const String:name[], bool:dontBroadcast)
{
	if(IsInReady()) return;
	new victim = GetClientOfUserId(GetEventInt(event, "userid"));
	if ( victim == 0 || !IsClientConnected(victim)||!IsClientInGame(victim)) return;
	
	new attacker = GetClientOfUserId(GetEventInt(event, "attacker"));
	
	decl String:weapon[15];
	GetEventString(event, "weapon", weapon, sizeof(weapon));
	
	decl String:victimName[128];
	GetClientName(victim,victimName,128);
	//CPrintToChatAll("attacker: %d - victim: %d - weapon: %s",attacker,victim,weapon);
	if(attacker == 0 && !IsWitch(GetEventInt(event, "attackerentid")) && GetClientTeam(victim) == 2 && !ClientHasDown[victim]) //倒地不算了
	{
		if(ClientGrabLedge[victim])//掛邊
		{
			for (new i = 1; i < MaxClients; i++)
				if (IsClientInGame(i) && IsClientConnected(i) && !IsFakeClient(i) && (GetClientTeam(i) == 1 || GetClientTeam(i) == 2))
					CPrintToChat(i,"{default}[{olive}TS{default}] %T","fell from top floor.",i,victimName);
		}
		else if (StrEqual(weapon,"infected")) //普通感染者抓死
			return;
		else
			CreateTimer(1.0,Timer_CheckPunch,victim);
	}	
	
	if (attacker == 0 ||!IsClientConnected(attacker) || !IsClientInGame(attacker) ) return;
	decl String:attackerName[128];
	GetClientName(attacker,attackerName,128);
	if(GetClientTeam(attacker) == 2 ) //人類 kill
	{
		if(GetClientTeam(victim) == 2 && victim != attacker)//友傷
		{
			for (new i = 1; i < MaxClients; i++)
				if (IsClientInGame(i) && IsClientConnected(i) && !IsFakeClient(i) && (GetClientTeam(i) == 1 || GetClientTeam(i) == 2))
					CPrintToChat(i,"{default}[{olive}TS{default}] %T","player kill teammate",i,attackerName, victimName);
		}
	}	
}

public Action: Timer_CheckPunch(Handle:hTimer, any:client)
{
	if(!IsClientConnected(client)||!IsClientInGame(client)) return;
	
	decl String:clientName[128];
	GetClientName(client,clientName,128);
	if(IsTankPounchClient(client))
		CPrintToChatAll("{green}[TS] %t","Tank Punch survivor fly away and die",clientName);
	else if(!IsFakeClient(client))
		CPrintToChatAll("{green}[TS] {olive}%N{default} : %t",client,"Survivor suicides");
}

public Action:Event_HurtConcise(Handle:event, const String:name[], bool:dontBroadcast)
{
	if(IsInReady()) return;
	
	new attacker = GetEventInt(event, "attackerentid");
	new victim = GetClientOfUserId(GetEventInt(event, "userid"));
	if(attacker ==0 && IsClientConnected(victim) && IsClientInGame(victim) && GetClientTeam(victim) == 2)
	{
		if(GetEntProp(victim, Prop_Send, "m_isHangingFromLedge"))
		{
			return;
		}
		if(IsIncapacitated(victim)) 
		{
			CreateTimer(1.0,COLD_DOWN,victim);
		}
	}
	
	if (!GetConVarInt(FFenabled) || attacker > MaxClients || attacker < 1 || !IsClientConnected(attacker) || !IsClientInGame(attacker) || IsFakeClient(attacker) || GetClientTeam(attacker) != 2 || !IsClientInGame(victim) || !IsClientConnected(victim) || GetClientTeam(victim) != 2)
		return;  //if director_ready_duration is 0, it usually means that the game is in a ready up state like downtown1's ready up mod.  This allows me to disable the FF messages in ready up.
	new damage = GetEventInt(event, "dmg_health");
	if (FFTimer[attacker] != null)  //If the player is already friendly firing teammates, resets the announce timer and adds to the damage
	{
		DamageCache[attacker][victim] += damage;
		delete FFTimer[attacker];
		FFTimer[attacker] = CreateTimer(1.0, AnnounceFF, attacker);
	}
	else //If it's the first friendly fire by that player, it will start the announce timer and store the damage done.
	{
		DamageCache[attacker][victim] = damage;
		delete FFTimer[attacker];
		FFTimer[attacker] = CreateTimer(1.0, AnnounceFF, attacker);
		for (new i = 1; i < 19; i++)
		{
			if (i != attacker && i != victim)
			{
				DamageCache[attacker][i] = 0;
			}
		}
	}
}

public void Event_IncapacitatedStart(Event event, const char[] name, bool dontBroadcast) 
{
	int victim = GetClientOfUserId(event.GetInt("userid"));
	int attacker = GetClientOfUserId(event.GetInt("attacker"));

	if (FFenabled.BoolValue == false || 
	attacker == victim ||
	attacker > MaxClients || 
	attacker < 1 || 
	!IsClientInGame(attacker) || 
	IsFakeClient(attacker) || 
	GetClientTeam(attacker) != 2 || 
	!IsClientInGame(victim) || 
	GetClientTeam(victim) != 2)
		return;  

	int damage = GetClientHealth(victim) + RoundToFloor(GetTempHealth(victim));
	if (FFTimer[attacker] != null)  //If the player is already friendly firing teammates, resets the announce timer and adds to the damage
	{
		DamageCache[attacker][victim] += damage;
		delete FFTimer[attacker];
		FFTimer[attacker] = CreateTimer(1.0, AnnounceFF, attacker);
	}
	else //If it's the first friendly fire by that player, it will start the announce timer and store the damage done.
	{
		DamageCache[attacker][victim] = damage;
		delete FFTimer[attacker];
		FFTimer[attacker] = CreateTimer(1.0, AnnounceFF, attacker);
		for (int i = 1; i <= MaxClients; i++)
		{
			if (i != attacker && i != victim)
			{
				DamageCache[attacker][i] = 0;
			}
		}
	}
}

public Action:COLD_DOWN(Handle:timer,any:victim)
{
	if(!IsClientConnected(victim)||!IsClientInGame(victim)) return;
	if(IsPlayerAlive(victim) && IsIncapacitated(victim)) 
	{
		ClientHasDown[victim] = true;
	}
}

public Action AnnounceFF(Handle:timer, int attackerc) //Called if the attacker did not friendly fire recently, and announces all FF they did
{
	decl String:victim[128];
	decl String:attacker[128];

	if (IsClientInGame(attackerc) && IsClientConnected(attackerc) && !IsFakeClient(attackerc))
		GetClientName(attackerc, attacker, sizeof(attacker));
	else
		attacker = "Disconnected Player";
	for (new i = 1; i < MaxClients; i++)
	{
		if (DamageCache[attackerc][i] != 0 && attackerc != i)
		{
			if (IsClientInGame(i) && IsClientConnected(i))
			{
				GetClientName(i, victim, sizeof(victim));
				switch(GetConVarInt(AnnounceType))
				{
					case 1:
					{
						if (IsClientInGame(attackerc) && IsClientConnected(attackerc) && !IsFakeClient(attackerc))
							CPrintToChat(attackerc, "[{olive}TS{default}] %T","l4dffannounce1",attackerc,DamageCache[attackerc][i],victim);
						if (IsClientInGame(i) && IsClientConnected(i) && !IsFakeClient(i))
							CPrintToChat(i, "[{olive}TS{default}] %T","l4dffannounce2",i,attacker,DamageCache[attackerc][i]);
					}
					case 2:
					{
						if (IsClientInGame(attackerc) && IsClientConnected(attackerc) && !IsFakeClient(attackerc))
							PrintHintText(attackerc, "%T","l4dffannounce13",attackerc,DamageCache[attackerc][i],victim);
						if (IsClientInGame(i) && IsClientConnected(i) && !IsFakeClient(i))
							PrintHintText(i, "%T","l4dffannounce14",i,attacker,DamageCache[attackerc][i]);
					}
					case 3:
					{
						if (IsClientInGame(attackerc) && IsClientConnected(attackerc) && !IsFakeClient(attackerc))
							PrintCenterText(attackerc, "%T","l4dffannounce13",attackerc,DamageCache[attackerc][i],victim);
						if (IsClientInGame(i) && IsClientConnected(i) && !IsFakeClient(i))
							PrintCenterText(i, "%T","l4dffannounce14",i,attacker,DamageCache[attackerc][i]);
					}
				}
			}
			DamageCache[attackerc][i] = 0;
		}
	}

	FFTimer[attackerc] = null;
	return Plugin_Continue;
}

public Event_ledge_grab(Handle:event, const String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	ClientGrabLedge[client] = true;
}

public Event_revive_success(Handle:event, const String:name[], bool:dontBroadcast)
{
	if(IsInReady()) return;
	
	new subject = GetClientOfUserId(GetEventInt(event, "subject"));//被救的那位
	if (subject<=0||!IsClientAndInGame(subject)) { return; } //just in case
	
	if (GetEventBool(event,"ledge_hang"))
	{
		ClientGrabLedge[subject] = false;
		return;
	}
	ClientHasDown[subject] = false;
}

public Action:OnBotSwap(Handle:event, const String:name[], bool:dontBroadcast) 
{
	if(IsInReady()) return Plugin_Continue;
	
	new bot = GetClientOfUserId(GetEventInt(event, "bot"));
	new player = GetClientOfUserId(GetEventInt(event, "player"));
	if (IsClientIndex(bot) && IsClientIndex(player)) 
	{
		if (StrEqual(name, "player_bot_replace")) 
		{
			ClientGrabLedge[bot] = ClientGrabLedge[player];
			ClientGrabLedge[player] = false;
			ClientHasDown[bot] = ClientHasDown[player];
			ClientHasDown[player] = false;
			
		}
		else 
		{
			ClientGrabLedge[player] = ClientGrabLedge[bot];
			ClientGrabLedge[bot] = false;
			ClientHasDown[player] = ClientHasDown[bot];
			ClientHasDown[bot] = false;
		}
	}
	return Plugin_Continue;
}

public Action:OnPlayerSpawn(Handle:event, const String:name[], bool:dontBroadcast)
{
	if(IsInReady()) return;
	
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	if(IsClientIndex(client)&&IsClientConnected(client)&&IsClientInGame(client)&&GetClientTeam(client)==2)
	{
		ClientGrabLedge[client] = false;
		ClientHasDown[client] = false;
	}
}

bool:IsClientIndex(client)
{
	return (client > 0 && client <= MaxClients);
}

stock IsIncapacitated(client)
{
	return GetEntProp(client, Prop_Send, "m_isIncapacitated");
}

stock IsClientAndInGame(client)
{
	if (0 < client && client <= MaxClients)
	{	
		return IsClientInGame(client);
	}
	return false;
}

bool IsWitch(int entity)
{
    if (entity > 0 && IsValidEntity(entity) && IsValidEdict(entity))
    {
        static char strClassName[64];
        GetEdictClassname(entity, strClassName, sizeof(strClassName));
        return strcmp(strClassName, "witch", false) == 0;
    }
    return false;
}

stock float GetTempHealth(int client)
{
	static float fCvarDecayRate = -1.0;

	if (fCvarDecayRate == -1.0)
		fCvarDecayRate = FindConVar("pain_pills_decay_rate").FloatValue;

	float fTempHealth = GetEntPropFloat(client, Prop_Send, "m_healthBuffer");
	fTempHealth -= (GetGameTime() - GetEntPropFloat(client, Prop_Send, "m_healthBufferTime")) * fCvarDecayRate;
	return fTempHealth < 0.0 ? 0.0 : fTempHealth;
}

void ResetTimer()
{
	for (int i = 1; i <= MaxClients; i++)
	{
		delete FFTimer[i];
	}
}